---
title: 'Stateless Transformations'
description: 'Learn how stateless JSON transformations work in GlassFlow and how to configure them'
---
import { Callout, Tabs } from 'nextra/components'

# Stateless Transformations

The **Stateless Transformation** feature lets you reshape event payloads on the fly using expression-based mappings.  
It is called *stateless* because each event is transformed independently, without relying on any stored state or history.

Use stateless transformations when you need to:

- **Normalize fields** (e.g., parse URLs, user agents, or timestamps)
- **Derive new fields** from existing ones
- **Clean up or reformat data** before it lands in ClickHouse
- **Map nested JSON structures** into a flat schema

## How It Works

Internally, stateless transformations are powered by the [`expr`](https://github.com/expr-lang/expr) expression engine and a set of custom helper functions.
Each transformation defines:

- **`expression`**: how to compute the new value, using the input JSON as context
- **`output_name`**: the resulting field name in the transformed payload
- **`output_type`**: the expected type of the result (e.g., `string`, `int`, `float`, `bool`)

### Internal Process

1. **Input Parsing**: The original Kafka event is parsed as a JSON object (`map[string]any`).
2. **Expression Evaluation**:  
   For each configured transformation, GlassFlow evaluates the `expression` against the input object.
3. **Type Conversion**:  
   The result of the expression is converted to the configured `output_type` (string, int, float64, bool, or `[]string`).
4. **Output Assembly**:  
   All transformed fields are collected into a new JSON object keyed by `output_name`.
5. **Downstream Processing**:  
   The transformed JSON is then used for schema mapping and written to ClickHouse.

If no stateless transformations are configured, the input JSON is passed through unchanged.

### Expression Context

Inside an expression, you can reference any field from the input JSON by its name, for example:

- `url`, `user_agent`, `status`, `age`
- Nested fields using dot notation, e.g. `user.id`, `payload.metadata.referrer`

The expression engine is type-aware and supports arithmetic, string operations, conditionals, and logical operators.

## Helper Functions

In addition to standard `expr` operators, GlassFlow provides helper functions useful for web / event data pipelines.
Use them directly in expressions, e.g. `upper(status)`, `parseUserAgent(user_agent, "device")`.

Each function is listed below with a short description and an example showing **expression** → **output**.

---

### parseQuery

Parses a URL query string into a map of key/value pairs. Useful for deriving fields from `?key=value&foo=bar`-style strings.

| Expression | Example output |
|------------|----------------|
| `parseQuery('a=1&b=2&c=hello')` | `{"a": "1", "b": "2", "c": "hello"}` |
| `parseQuery(query_string)` (with `query_string` = `"utm_source=google"`) | `{"utm_source": "google"}` |

---

### getQueryParam / getNestedParam

Return the value of a specific query parameter from a query string. Both functions behave the same; `getNestedParam` also works when the parsed value is not a simple string.

| Expression | Example output |
|------------|----------------|
| `getQueryParam('a=1&b=2', 'b')` | `"2"` |
| `getQueryParam(url_query, 'utm_campaign')` (with `url_query` = `"utm_campaign=winter"`) | `"winter"` |
| `getQueryParam('a=1&b=2', 'missing')` | `""` |

---

### urlDecode

URL-decodes an encoded string (e.g. `%20` → space, `%2B` → `+`).

| Expression | Example output |
|------------|----------------|
| `urlDecode('hello%20world')` | `"hello world"` |
| `urlDecode('a%3D1%26b%3D2')` | `"a=1&b=2"` |

---

### parseISO8601

Parses common ISO-8601 timestamp strings and returns a Unix timestamp in **seconds**. Supports formats such as `2006-01-02T15:04:05Z` and `2006-01-02 15:04:05.000000`.

| Expression | Example output |
|------------|----------------|
| `parseISO8601('2024-06-15T14:30:00Z')` | `1718461800` |
| `parseISO8601(timestamp_field)` (with `timestamp_field` = `"2024-01-01T00:00:00Z"`) | `1704067200` |
| `parseISO8601('')` or invalid input | `0` |

---

### toDate

Converts a Unix timestamp (seconds) or a `time.Time` value into a `YYYY-MM-DD` date string.

| Expression | Example output |
|------------|----------------|
| `toDate(1718458200)` | `"2024-06-15"` |
| `toDate(parseISO8601('2024-06-15T14:30:00Z'))` | `"2024-06-15"` |

---

### parseUserAgent

Extracts structured information from a user agent string. The second argument must be one of: `"device"`, `"browser"`, or `"os"`.

Example `user_agent` value used below:  
`Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36`

| Expression | Example output |
|------------|----------------|
| `parseUserAgent(user_agent, "device")` | `"Mobile"` (or `"Desktop"` / `"Tablet"` for other UAs) |
| `parseUserAgent(user_agent, "browser")` | `"Chrome"` |
| `parseUserAgent(user_agent, "os")` | `"Android"` |

---

### containsStr

Returns whether the first string contains the second string (substring check).

| Expression | Example output |
|------------|----------------|
| `containsStr('hello world', 'world')` | `true` |
| `containsStr('hello world', 'xyz')` | `false` |
| `containsStr(path, '/api/')` (with `path` = `'/api/v1/users'`) | `true` |

---

### hasPrefix

Returns whether the first string starts with the second string.

| Expression | Example output |
|------------|----------------|
| `hasPrefix('hello world', 'hello')` | `true` |
| `hasPrefix('hello world', 'world')` | `false` |
| `hasPrefix(path, '/g/')` (with `path` = `'/g/collect'`) | `true` |

---

### hasSuffix

Returns whether the first string ends with the second string.

| Expression | Example output |
|------------|----------------|
| `hasSuffix('file.json', '.json')` | `true` |
| `hasSuffix('file.json', '.txt')` | `false` |

---

### upper

Converts a string to uppercase.

| Expression | Example output |
|------------|----------------|
| `upper('hello')` | `"HELLO"` |
| `upper(status)` (with `status` = `"pending"`) | `"PENDING"` |

---

### lower

Converts a string to lowercase.

| Expression | Example output |
|------------|----------------|
| `lower('HELLO')` | `"hello"` |
| `lower(type)` (with `type` = `"EVENT"`) | `"event"` |

---

### trim

Trims leading and trailing whitespace from a string.

| Expression | Example output |
|------------|----------------|
| `trim('  hello  ')` | `"hello"` |
| `trim(raw_input)` (with `raw_input` = `"\t value \n"`) | `"value"` |

---

### split

Splits a string by a separator and returns an array of strings.

| Expression | Example output |
|------------|----------------|
| `split('a,b,c', ',')` | `["a", "b", "c"]` |
| `split('one-two-three', '-')` | `["one", "two", "three"]` |
| `split(path, '/')` (with `path` = `"/api/v1"`) | `["", "api", "v1"]` |

---

### join

Joins an array of values into a single string using the given separator. The first argument must be an array (e.g. the result of `split`).

| Expression | Example output |
|------------|----------------|
| `join(['a', 'b', 'c'], '-')` | `"a-b-c"` |
| `join(['x', 'y', 'z'], ' ')` | `"x y z"` |

---

### replace

Replaces all occurrences of a substring with another string.

| Expression | Example output |
|------------|----------------|
| `replace('hello world', 'world', 'there')` | `"hello there"` |
| `replace(url, 'http://', 'https://')` (with `url` = `'http://example.com'`) | `"https://example.com"` |

---

### toInt

Converts a value to an integer. Returns `0` for empty or invalid input.

| Expression | Example output |
|------------|----------------|
| `toInt('42')` | `42` |
| `toInt('3.14')` | `0` (invalid for int) |
| `toInt('abc')` | `0` (invalid for int) |
| `toInt(age_str)` (with `age_str` = `"25"`) | `25` |

---

### toFloat

Converts a value to a float. Returns `0.0` for empty or invalid input.

| Expression | Example output |
|------------|----------------|
| `toFloat('3.14')` | `3.14` |
| `toFloat('42')` | `42` |
| `toFloat(price_str)` (with `price_str` = `"19.99"`) | `19.99` |

---

### toString

Converts a value to a string. Returns `""` for empty input.

| Expression | Example output |
|------------|----------------|
| `toString(42)` | `"42"` |
| `toString(3.14)` | `"3.14"` |
| `toString(id)` (with `id` = `12345`) | `"12345"` |

---

### keys

Returns all keys of a JSON object (map), sorted alphabetically.

| Expression | Example output |
|------------|----------------|
| `keys(parseQuery('a=1&b=2'))` | `["a", "b"]` |
| `keys(payload)` (with `payload` = `{"x": 1, "y": 2}`) | `["x", "y"]` |

---

### waterfall

Returns the first non-empty value from a list of candidates. Accepts either multiple arguments or a single array. Useful for fallbacks (e.g. prefer `utm_source`, then `source`, then `"direct"`).

| Expression | Example output |
|------------|----------------|
| `waterfall('', 'b', 'c')` | `"b"` |
| `waterfall(utm_source, source, 'direct')` (with `utm_source` = `""`, `source` = `"newsletter"`) | `"newsletter"` |
| `waterfall('', '', 'last')` | `"last"` |

---

### extractPathType

Maps a known path to a request type. Recognized paths: `/g/collect` → `"collect"`, `/_/set_cookie` → `"set_cookie"`; any other path → `"unknown"`.

| Expression | Example output |
|------------|----------------|
| `extractPathType('/g/collect')` | `"collect"` |
| `extractPathType(path)` (with `path` = `"/_/set_cookie"`) | `"set_cookie"` |
| `extractPathType('/other')` | `"unknown"` |

---

### hasKeyPrefix

Returns whether any key in the given map starts with one of the given prefixes. First argument: map (object); second: array of prefix strings.

| Expression | Example output |
|------------|----------------|
| `hasKeyPrefix(payload, ['ga_', 'gclid_'])` (with `payload` = `{"ga_session_id": "123"}`) | `true` |
| `hasKeyPrefix(payload, ['utm_'])` (with `payload` = `{"page": "/"}`) | `false` |

---

### hasAnyKey

Returns whether the given map has at least one of the given keys. First argument: map; second: array of key names.

| Expression | Example output |
|------------|----------------|
| `hasAnyKey(payload, ['user_id', 'client_id'])` (with `payload` = `{"client_id": "abc"}`) | `true` |
| `hasAnyKey(payload, ['user_id', 'client_id'])` (with `payload` = `{"page": "/"}`) | `false` |

## Configuration

Stateless transformations are configured as part of the pipeline’s transformation section.  
They are typically surfaced through the UI as *derived fields* or *expression-based mappings*.

### Configuration Structure

<Tabs items={['Web UI', 'Pipeline JSON']} defaultIndex="0" storageKey="client_preference">
  <Tabs.Tab>
    In the pipeline wizard, open the **Transformation** step. By default, all input fields from your topic are listed as **passthrough**—they are forwarded to the output unchanged. You can edit a passthrough field to add a transformation, or click **Add Field** to define a new derived field.

    <img alt="Stateless Transformation Configuration Passthrough" src="/assets/ui_stateless_transformation_configuration_passthrough.png" />

    You can build each transformation in two ways:

    - **Builder** (default): Use the visual builder to pick a function, arguments, and optional arithmetic. Best for common patterns like string normalization or parsing.
    - **Raw Expression**: Type an expression directly (e.g. `upper(status)` or `parseUserAgent(user_agent, "device")`). Use this for complex logic or when the builder does not support what you need.

    **Builder mode:**

    <img alt="Transformation Builder" src="/assets/ui_stateless_transformation_configuration_builder.png" />

    **Raw expression mode:**

    <img alt="Transformation Raw Expression" src="/assets/ui_stateless_transformation_configuration_raw_expression.png" />
  </Tabs.Tab>
  <Tabs.Tab>
    In the pipeline JSON, stateless transformations use the following structure. The `transform` array lists every field that appears in the output—both derived fields (with expressions) and passthrough fields (e.g. `expression: "user_id"` to pass `user_id` through unchanged).

    ```json
    {
      "stateless_transformation": {
        "enabled": true,
        "id": "my-stateless-transformation",
        "type": "expr_lang_transform",
        "config": {
            "transform": [
                {
                    "expression": "upper(status)",
                    "output_name": "status_normalized",
                    "output_type": "string"
                },
                {
                    "expression": "parseUserAgent(user_agent, 'device')",
                    "output_name": "device_type",
                    "output_type": "string"
                },
                {
                    "expression": "user_id",
                    "output_name": "user_id",
                    "output_type": "string"
                }
            ]
        }
      }
    }
    ```

    In the `schema` section, use the transformation **`id`** as **`source_id`** for every field that comes from the transformation output (so the sink knows which stream to read from). The `source_id` in the example below matches the `id` above (`my-stateless-transformation`).

    ```json
    {
      "schema": {
        "fields": [
          {
            "source_id": "my-stateless-transformation",
            "name": "user_id",
            "type": "string"
          },
          {
            "source_id": "my-stateless-transformation",
            "name": "status_normalized",
            "type": "string"
          },
          {
            "source_id": "my-stateless-transformation",
            "name": "device_type",
            "type": "string"
          }
        ]
      }
    }
    ```

    For the full field reference, see the [Pipeline JSON Reference](/configuration/pipeline-json-reference#stateless-transformation-configuration).
  </Tabs.Tab>
</Tabs>

## Examples

### Example 1: Normalizing Status and Extracting Device

```json
{
  "expression": "upper(status)",
  "output_name": "status_normalized",
  "output_type": "string"
}
```

```json
{
  "expression": "parseUserAgent(user_agent, 'device')",
  "output_name": "device_type",
  "output_type": "string"
}
```

Used together, these transformations produce fields like `status_normalized = 'ACTIVE'` and `device_type = 'Mobile'` from the raw event.

### Example 2: Parsing Timestamp and URL Parameters

```json
{
  "expression": "parseISO8601(timestamp)",
  "output_name": "event_ts",
  "output_type": "int64"
}
```

```json
{
  "expression": "getQueryParam(query_string, 'utm_source')",
  "output_name": "utm_source",
  "output_type": "string"
}
```

These expressions convert a string timestamp into a numeric Unix timestamp and extract marketing parameters from a query string.

## Best Practices

- **Keep expressions focused**:  
  Prefer several small, clear transformations over one very complex expression.
- **Validate transformations with sample data**:  
  Use the UI or SDK evaluation helpers (where available) to test expressions before deploying.
- **Align `output_type` with ClickHouse schema**:  
  Make sure the type you choose matches the target ClickHouse column type to avoid conversion errors.
- **Use helpers for common patterns**:  
  Offload parsing and normalization (timestamps, user agents, query strings) to the provided helper functions instead of re-implementing logic inside expressions.

## Related Documentation

- [Transformations Overview](/configuration/transformations)
- [Pipeline JSON Reference](/configuration/pipeline-json-reference)
- [Data Flow](/architecture/data-flow)
