---
title: 'Stateless Transformations'
description: 'Learn how stateless JSON transformations work in GlassFlow and how to configure them'
---
import { Callout, Tabs } from 'nextra/components'

# Stateless Transformations

The **Stateless Transformation** feature lets you reshape event payloads on the fly using expression-based mappings.  
It is called *stateless* because each event is transformed independently, without relying on any stored state or history.

Use stateless transformations when you need to:

- **Normalize fields** (e.g., parse URLs, user agents, or timestamps)
- **Derive new fields** from existing ones
- **Clean up or reformat data** before it lands in ClickHouse
- **Map nested JSON structures** into a flat schema

## How It Works

Internally, stateless transformations are powered by the [`expr`](https://github.com/expr-lang/expr) expression engine and a set of custom helper functions.
Each transformation defines:

- **`expression`**: how to compute the new value, using the input JSON as context
- **`output_name`**: the resulting field name in the transformed payload
- **`output_type`**: the expected type of the result (e.g., `string`, `int`, `float`, `bool`)

### Internal Process

1. **Input Parsing**: The original Kafka event is parsed as a JSON object (`map[string]any`).
2. **Expression Evaluation**:  
   For each configured transformation, GlassFlow evaluates the `expression` against the input object.
3. **Type Conversion**:  
   The result of the expression is converted to the configured `output_type` (string, int, float64, bool, or `[]string`).
4. **Output Assembly**:  
   All transformed fields are collected into a new JSON object keyed by `output_name`.
5. **Downstream Processing**:  
   The transformed JSON is then used for schema mapping and written to ClickHouse.

If no stateless transformations are configured, the input JSON is passed through unchanged.

### Expression Context

Inside an expression, you can reference any field from the input JSON by its name, for example:

- `url`, `user_agent`, `status`, `age`
- Nested fields using dot notation, e.g. `user.id`, `payload.metadata.referrer`

The expression engine is type-aware and supports arithmetic, string operations, conditionals, and logical operators.

## Helper Functions

In addition to standard `expr` operators, GlassFlow provides helper functions useful for web / event data pipelines.
Some of the most commonly used helpers are:

- **`parseQuery(queryString)`**:  
  Parses a query string into a map of key/value pairs.
- **`getQueryParam(queryString, key)` / `getNestedParam(queryString, key)`**:  
  Returns the value of a specific query parameter.
- **`urlDecode(value)`**:  
  URL-decodes an encoded string.
- **`parseISO8601(timestamp)`**:  
  Parses common ISO-8601 timestamp formats and returns a Unix timestamp (seconds).
- **`toDate(unixSeconds)`**:  
  Converts a Unix timestamp (seconds) into a `YYYY-MM-DD` date string.
- **`parseUserAgent(ua, field)`**:  
  Extracts `device`, `browser`, or `os` from a user agent string.
- **`containsStr(str, substr)`**, **`hasPrefix(str, prefix)`**, **`hasSuffix(str, suffix)`**:  
  Basic string search/validation.
- **`upper(str)`**, **`lower(str)`**, **`trim(str)`**:  
  String normalization helpers.
- **`split(str, sep)`**, **`join(values, sep)`**, **`replace(str, old, new)`**:  
  Advanced string manipulation.
- **`toInt(value)`**, **`toFloat(value)`**, **`toString(value)`**:  
  Safe type conversion helpers.
- **`keys(map)`**:  
  Returns all keys in a JSON object, sorted.
- **`waterfall(values...)`**:  
  Returns the first non-empty value from a list (or array) of candidates.

> These helpers are available directly inside the expression, e.g. `upper(status)`, `parseUserAgent(user_agent, "device")`.

## Configuration

Stateless transformations are configured as part of the pipeline’s transformation section.  
They are typically surfaced through the UI as *derived fields* or *expression-based mappings*.

### Configuration Structure

<Tabs items={['Web UI', 'Pipeline JSON']} defaultIndex="0" storageKey="client_preference">
  <Tabs.Tab>
    In the pipeline wizard, open the **Transformation** step. By default, all input fields from your topic are listed as **passthrough**—they are forwarded to the output unchanged. You can edit a passthrough field to add a transformation, or click **Add Field** to define a new derived field.

    <img alt="Stateless Transformation Configuration Passthrough" src="/assets/ui_stateless_transformation_configuration_passthrough.png" />

    You can build each transformation in two ways:

    - **Builder** (default): Use the visual builder to pick a function, arguments, and optional arithmetic. Best for common patterns like string normalization or parsing.
    - **Raw Expression**: Type an expression directly (e.g. `upper(status)` or `parseUserAgent(user_agent, "device")`). Use this for complex logic or when the builder does not support what you need.

    **Builder mode:**

    <img alt="Transformation Builder" src="/assets/ui_stateless_transformation_configuration_builder.png" />

    **Raw expression mode:**

    <img alt="Transformation Raw Expression" src="/assets/ui_stateless_transformation_configuration_raw_expression.png" />
  </Tabs.Tab>
  <Tabs.Tab>
    In the pipeline JSON, stateless transformations use the following structure. The `transform` array lists every field that appears in the output—both derived fields (with expressions) and passthrough fields (e.g. `expression: "user_id"` to pass `user_id` through unchanged).

    ```json
    {
      "stateless_transformation": {
        "enabled": true,
        "id": "my-stateless-transformation",
        "type": "expr_lang_transform",
        "config": {
            "transform": [
                {
                    "expression": "upper(status)",
                    "output_name": "status_normalized",
                    "output_type": "string"
                },
                {
                    "expression": "parseUserAgent(user_agent, 'device')",
                    "output_name": "device_type",
                    "output_type": "string"
                },
                {
                    "expression": "user_id",
                    "output_name": "user_id",
                    "output_type": "string"
                }
            ]
        }
      }
    }
    ```

    In the `schema` section, use the transformation **`id`** as **`source_id`** for every field that comes from the transformation output (so the sink knows which stream to read from). The `source_id` in the example below matches the `id` above (`my-stateless-transformation`).

    ```json
    {
      "schema": {
        "fields": [
          {
            "source_id": "my-stateless-transformation",
            "name": "user_id",
            "type": "string"
          },
          {
            "source_id": "my-stateless-transformation",
            "name": "status_normalized",
            "type": "string"
          },
          {
            "source_id": "my-stateless-transformation",
            "name": "device_type",
            "type": "string"
          }
        ]
      }
    }
    ```

    For the full field reference, see the [Pipeline JSON Reference](/configuration/pipeline-json-reference#stateless-transformation-configuration).
  </Tabs.Tab>
</Tabs>

## Examples

### Example 1: Normalizing Status and Extracting Device

```json
{
  "expression": "upper(status)",
  "output_name": "status_normalized",
  "output_type": "string"
}
```

```json
{
  "expression": "parseUserAgent(user_agent, 'device')",
  "output_name": "device_type",
  "output_type": "string"
}
```

Used together, these transformations produce fields like `status_normalized = 'ACTIVE'` and `device_type = 'Mobile'` from the raw event.

### Example 2: Parsing Timestamp and URL Parameters

```json
{
  "expression": "parseISO8601(timestamp)",
  "output_name": "event_ts",
  "output_type": "int64"
}
```

```json
{
  "expression": "getQueryParam(query_string, 'utm_source')",
  "output_name": "utm_source",
  "output_type": "string"
}
```

These expressions convert a string timestamp into a numeric Unix timestamp and extract marketing parameters from a query string.

## Best Practices

- **Keep expressions focused**:  
  Prefer several small, clear transformations over one very complex expression.
- **Validate transformations with sample data**:  
  Use the UI or SDK evaluation helpers (where available) to test expressions before deploying.
- **Align `output_type` with ClickHouse schema**:  
  Make sure the type you choose matches the target ClickHouse column type to avoid conversion errors.
- **Use helpers for common patterns**:  
  Offload parsing and normalization (timestamps, user agents, query strings) to the provided helper functions instead of re-implementing logic inside expressions.

## Related Documentation

- [Transformations Overview](/configuration/transformations)
- [Pipeline JSON Reference](/configuration/pipeline-json-reference)
- [Data Flow](/architecture/data-flow)
