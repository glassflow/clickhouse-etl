package models

import (
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func TestNewKafkaSourceComponent(t *testing.T) {
	testCases := []struct {
		desc                 string
		args                 KafkaSourceArgs
		expectedErr          error
		expectedComponentNil bool
	}{
		{
			desc: "valid kafka source with deduplication",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "string",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          nil,
			expectedComponentNil: false,
		},
		{
			desc: "valid kafka source without deduplication",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               false,
				DedupKey:                   "",
				DedupType:                  "",
				DedupWindow:                0,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          nil,
			expectedComponentNil: false,
		},
		{
			desc: "valid kafka source without auth",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   true,
				SASLUser:                   "",
				SASLPassword:               "",
				SASLMechanism:              "",
				Protocol:                   "PLAINTEXT",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               false,
				DedupKey:                   "",
				DedupType:                  "",
				DedupWindow:                0,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          nil,
			expectedComponentNil: false,
		},
		{
			desc: "no servers",
			args: KafkaSourceArgs{
				Servers:                    []string{},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "string",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "must have at least one kafka server"},
			expectedComponentNil: true,
		},
		{
			desc: "empty servers",
			args: KafkaSourceArgs{
				Servers:                    []string{" "},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "string",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "kafka server cannot be empty"},
			expectedComponentNil: true,
		},
		{
			desc: "empty protocol",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "string",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "SASL protocol cannot be empty"},
			expectedComponentNil: true,
		},
		{
			desc: "empty mechanism",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "string",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "SASL mechanism cannot be empty"},
			expectedComponentNil: true,
		},
		{
			desc: "unsupported mechanism",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-105",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "string",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "Unsupported SASL mechanism: SCRAM-SHA-105; allowed: SCRAM-SHA-256, SCRAM-SHA-512, PLAIN"},
			expectedComponentNil: true,
		},
		{
			desc: "empty username",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "   ",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "string",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "SASL username cannot be empty"},
			expectedComponentNil: true,
		},
		{
			desc: "empty password",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "string",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "SASL password cannot be empty"},
			expectedComponentNil: true,
		},
		{
			desc: "invalid topic schema type",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "string",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "protobuf",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "kafka only supports json schema"},
			expectedComponentNil: true,
		},
		{
			desc: "empty topic schema field",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "string",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					" ": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "kafka topic's schema fields cannot be empty"},
			expectedComponentNil: true,
		},
		{
			desc: "unsupported dedup key type",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "float32",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "float32",
				},
			},
			expectedErr:          PipelineConfigError{msg: "unsupported dedup key type"},
			expectedComponentNil: true,
		},
		{
			desc: "unsupported topic schema data type",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "int",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "uuid",
				},
			},
			expectedErr:          PipelineConfigError{msg: "unsuppored kafka data type: uuid"},
			expectedComponentNil: true,
		},
		{
			desc: "missing dedup key from schema",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "earliest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "int",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"id": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "topic schema must contain specified dedup key"},
			expectedComponentNil: true,
		},
		{
			desc: "invalid consumer group offset",
			args: KafkaSourceArgs{
				Servers:                    []string{"http://localhost:9092"},
				SkipAuth:                   false,
				SASLUser:                   "user",
				SASLPassword:               "password",
				SASLMechanism:              "SCRAM-SHA-256",
				Protocol:                   "SASL_SSL",
				RootCert:                   "",
				TopicName:                  "topic1",
				ConsumerGroupInitialOffset: "oldest",
				DedupEnabled:               true,
				DedupKey:                   "event_id",
				DedupType:                  "int",
				DedupWindow:                5 * time.Second,
				SchemaKind:                 "json",
				SchemaMap: map[string]string{
					"event_id": "string",
				},
			},
			expectedErr:          PipelineConfigError{msg: "invalid consumer_group_initial_offset; allowed values: `earliest` or `latest`"},
			expectedComponentNil: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.desc, func(t *testing.T) {
			component, err := NewKafkaSourceComponent(tc.args)

			if tc.expectedErr != nil {
				require.EqualError(t, err, tc.expectedErr.Error())
			}
			require.Equal(t, tc.expectedComponentNil, component == nil)
		})
	}
}
