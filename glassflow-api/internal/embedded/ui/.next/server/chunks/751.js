exports.id=751,exports.ids=[751],exports.modules={19226:(a,b,c)=>{"use strict";function d(a){let{servers:b,securityProtocol:c,authMethod:d,certificate:e}=a,f="true"===process.env.NEXT_PUBLIC_IN_DOCKER?b.replace(/localhost|127\.0\.0\.1/g,"host.docker.internal"):b;if("NO_AUTH"===d&&(!b||!c)||"NO_AUTH"!==d&&(!b||!c||!d))return{success:!1,error:"Missing required Kafka connection parameters"};if("SASL_SSL"!==c&&"SASL_PLAINTEXT"!==c&&"SSL"!==c&&"PLAINTEXT"!==c)return{success:!1,error:"Unsupported security protocol"};let g={brokers:f.split(","),securityProtocol:c,authMethod:"NO_AUTH"===d?void 0:d,clientId:"kafka-local-test"};switch(("SASL_SSL"===c||"SSL"===c)&&e&&(g.certificate=e),d){case"NO_AUTH":break;case"SASL/PLAIN":let{username:h,password:i,consumerGroup:j}=a;if(!h||!i)return{success:!1,error:"Missing required SASL/PLAIN parameters"};g.username=h,g.password=i;break;case"SASL/JAAS":let{jaasConfig:k}=a;if(!k)return{success:!1,error:"Missing required JAAS configuration"};g.jaasConfig=k;break;case"SASL/GSSAPI":let{kerberosPrincipal:l,kerberosKeytab:m,kerberosRealm:n,kdc:o,serviceName:p,krb5Config:q,useTicketCache:r,ticketCachePath:s}=a;if(!l||!m||!p)return{success:!1,error:"Missing required Kerberos parameters"};g.kerberosPrincipal=l,g.kerberosKeytab=m,n&&(g.kerberosRealm=n),o&&(g.kdc=o),p&&(g.serviceName=p),q&&(g.krb5Config=q),r&&(g.useTicketCache=r),s&&(g.ticketCachePath=s);break;case"SASL/OAUTHBEARER":let{oauthBearerToken:t}=a;if(!t)return{success:!1,error:"Missing required OAuth Bearer token"};g.oauthBearerToken=t;break;case"SASL/SCRAM-256":case"SASL/SCRAM-512":let{username:u,password:v,consumerGroup:w}=a;if(!u||!v)return{success:!1,error:"Missing required SCRAM parameters"};g.username=u,g.password=v;break;case"AWS_MSK_IAM":let{awsRegion:x,awsAccessKey:y,awsAccessKeySecret:z,awsIAMRoleArn:A}=a;if(!x||!y||!z)return{success:!1,error:"Missing required AWS_MSK_IAM parameters"};g.awsRegion=x,g.awsAccessKey=y,g.awsAccessKeySecret=z,A&&(g.awsIAMRoleArn=A);break;case"Delegation tokens":let{delegationToken:B}=a;if(!B)return{success:!1,error:"Missing required delegation token"};g.delegationToken=B;break;case"SASL/LDAP":let{ldapServerUrl:C,ldapServerPort:D,ldapBindDn:E,ldapBindPassword:F,ldapUserSearchFilter:G,ldapBaseDn:H}=a;if(!C||!E||!F)return{success:!1,error:"Missing required LDAP parameters"};g.ldapServerUrl=C,D&&(g.ldapServerPort=D),g.ldapBindDn=E,g.ldapBindPassword=F,G&&(g.ldapUserSearchFilter=G),H&&(g.ldapBaseDn=H);break;case"mTLS":let{clientCert:I,clientKey:J,password:K}=a;if(!I||!J)return{success:!1,error:"Missing required mTLS parameters"};g.clientCert=I,g.clientKey=J,K&&(g.password=K);break;default:return{success:!1,error:`Unsupported authentication method: ${d}`}}return g}c.d(b,{P:()=>d})},21601:()=>{},27636:(a,b,c)=>{"use strict";c.d(b,{U:()=>l});var d=function(a){return a.KAFKAJS="kafkajs",a.GATEWAY="gateway",a}({});class e extends Error{constructor(a,b,c){super(a),this.code=b,this.cause=c,this.name="KafkaClientError"}}class f extends e{constructor(a,b){super(a,"CONNECTION_ERROR",b),this.name="KafkaConnectionError"}}let g=process.env.KAFKA_GATEWAY_URL||"http://localhost:8082";class h{constructor(a){this.config=a,console.log("[KafkaGateway] Client initialized")}buildGatewayRequest(){let a,b;if(!this.config.kerberosPrincipal||!this.config.kerberosKeytab||!this.config.krb5Config)throw Error("SASL/GSSAPI configuration is incomplete. Required: kerberosPrincipal, kerberosKeytab, krb5Config");let c=this.config.kerberosKeytab;if(c.startsWith("data:")){let a=c.split(",");a.length>1&&(c=a[1],console.log("[KafkaGateway] Extracted base64 keytab from data URL"))}let d=this.config.krb5Config;if(d.startsWith("data:")){let a=d.split(",");if(a.length>1){if(a[0].includes("base64"))d=a[1];else{let b=decodeURIComponent(a[1]);d=Buffer.from(b,"utf-8").toString("base64")}console.log("[KafkaGateway] Extracted krb5.conf from data URL")}}else this.isBase64(d)||(d=Buffer.from(d,"utf-8").toString("base64"),console.log("[KafkaGateway] Encoded krb5.conf to base64"));if(this.config.truststore?.certificates?b=Array.isArray(this.config.truststore.certificates)?this.config.truststore.certificates.join("\n"):this.config.truststore.certificates:this.config.certificate&&(b=this.config.certificate),b)if(b.startsWith("data:")){let c=b.split(",");if(c.length>1){if(c[0].includes("base64"))a=c[1];else{let b=decodeURIComponent(c[1]);a=Buffer.from(b,"utf-8").toString("base64")}console.log("[KafkaGateway] Extracted CA certificate from data URL")}}else this.isBase64(b)?a=b:(a=Buffer.from(b,"utf-8").toString("base64"),console.log("[KafkaGateway] Encoded CA certificate to base64"));return{bootstrapServers:this.config.brokers.join(","),securityProtocol:this.config.securityProtocol||"SASL_SSL",saslMechanism:"GSSAPI",serviceName:this.config.serviceName||"kafka",principal:this.config.kerberosPrincipal,keytab:c,krb5Conf:d,caCertificate:a}}isBase64(a){if(a.includes("-----BEGIN"))return!1;try{return Buffer.from(a,"base64").toString("base64")===a}catch{return!1}}async callGateway(a,b){try{let c=await fetch(`${g}${a}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(b),signal:AbortSignal.timeout(6e4)});if(!c.ok)throw Error(`Gateway returned ${c.status}: ${c.statusText}`);let d=await c.json();if(!d.success)throw new f(d.error||"Unknown gateway error");return d}catch(a){if(a instanceof f)throw a;if(a instanceof Error){if("AbortError"===a.name||"TimeoutError"===a.name)throw new f("Request to Kafka gateway timed out");throw new f(`Gateway communication failed: ${a.message}`)}throw new f("Unknown error communicating with Kafka gateway")}}async connect(){console.log("[KafkaGateway] Connect called (no-op for HTTP client)")}async testConnection(){console.log("[KafkaGateway] Testing connection via gateway service");try{let a=this.buildGatewayRequest();return await this.callGateway("/kafka/test-connection",a),console.log("[KafkaGateway] Connection test successful"),!0}catch(a){return console.error("[KafkaGateway] Connection test failed:",a),!1}}async send(a,b){throw Error("Message sending via gateway is not supported. Use a direct producer.")}async subscribe(a,b){throw Error("Topic subscription via gateway is not supported. Use a direct consumer.")}async consume(a){throw Error("Message consumption via gateway is not supported. Use a direct consumer.")}async getTopicMetadata(a){console.log(`[KafkaGateway] Fetching metadata for topic: ${a}`);let b=(await this.getTopicDetails()).find(b=>b.name===a);if(!b)throw new f(`Topic '${a}' not found`);return{name:b.name,partitions:b.partitionCount}}async listTopics(){console.log("[KafkaGateway] Fetching topics via gateway service");let a=this.buildGatewayRequest(),b=await this.callGateway("/kafka/topics",a);if(!b.topics)throw new f("Gateway returned no topics");return console.log(`[KafkaGateway] Retrieved ${b.topics.length} topics`),b.topics}async getTopicDetails(){console.log("[KafkaGateway] Fetching topic details via gateway service");let a=this.buildGatewayRequest(),b=await this.callGateway("/kafka/topic-details",a);if(!b.topicDetails)throw new f("Gateway returned no topic details");return console.log(`[KafkaGateway] Retrieved details for ${b.topicDetails.length} topics`),b.topicDetails}async fetchSampleEvent(a,b,c,d,e){console.log(`[KafkaGateway] Fetching sample event from topic: ${a}`);let f={...this.buildGatewayRequest(),topic:a,partition:e?.partition||0,maxMessages:1,fromBeginning:!c},g=await this.callGateway("/kafka/sample-events",f);if(console.log(`[KafkaGateway] Fetched event from topic ${a}`),g.event)try{return JSON.parse(g.event.value)}catch(a){return console.warn("[KafkaGateway] Failed to parse event value as JSON, using raw value"),g.event.value}return null}async createTopic(a,b){throw Error("Topic creation via gateway is not yet implemented")}async disconnect(){console.log("[KafkaGateway] Disconnect called (no-op for HTTP client)")}static async checkHealth(){try{let a=await fetch(`${g}/health`,{method:"GET",signal:AbortSignal.timeout(5e3)});if(!a.ok)return!1;let b=await a.json();return"healthy"===b.status}catch(a){return console.error("[KafkaGateway] Health check failed:",a),!1}}}let i=null;class j{static async createClient(a){let b=this.determineClientType(a);switch(console.log(`[KafkaClientFactory] Creating ${b} client for auth method: ${a.authMethod||"default"}`),b){case d.GATEWAY:return new h(a);case d.KAFKAJS:default:return await this.createKafkaJSClient(a)}}static determineClientType(a){return"SASL/GSSAPI"===a.authMethod?d.GATEWAY:d.KAFKAJS}static async createKafkaJSClient(a){if(!i){let a=await Promise.all([c.e(2442),c.e(7281)]).then(c.bind(c,57281));i=a.KafkaClient||a}return new i(a)}static isAuthMethodSupported(a){return!0}static getSupportedAuthMethods(){return["NO_AUTH","SASL/PLAIN","SASL/SCRAM-256","SASL/SCRAM-512","AWS_MSK_IAM","mTLS","SSL","SASL/GSSAPI"]}}async function k(a){return await j.createClient(a)}class l{async testConnection(a){return(await k(a)).testConnection()}async getTopics(a){let b=await k(a);try{return await b.listTopics()}finally{try{await b.disconnect()}catch(a){console.error("[KafkaService] Error disconnecting client:",a)}}}async getTopicDetails(a){let b=await k(a);try{if(!b.getTopicDetails)throw Error("getTopicDetails is not supported by this Kafka client");return await b.getTopicDetails()}finally{try{await b.disconnect()}catch(a){console.error("[KafkaService] Error disconnecting client:",a)}}}async fetchEvent({kafkaConfig:a,topic:b,format:c,getNext:d=!1,currentOffset:e=null,position:f,direction:g,currentPosition:h}){let i;if(!b)return{success:!1,error:"Missing required parameters",status:400};let j=await k(a);try{let a=new Promise((a,b)=>{setTimeout(()=>{b(Error("API timeout after 30 seconds"))},3e4)}),k={};if("latest"===f?k.position="latest":"earliest"===f?k.position="earliest":"previous"===g&&(k.direction="previous"),void 0!==h&&(k.currentPosition=h),!j.fetchSampleEvent)throw Error("fetchSampleEvent is not supported by this Kafka client");i=await Promise.race([j.fetchSampleEvent(b,c,d,e,k),a]);let l="latest"===f;return{success:!0,event:i,isMock:!1,metadata:i._metadata||null,offset:i._metadata?.offset||null,hasMoreEvents:!l,isAtLatest:l,isAtEarliest:"earliest"===f,position:f||"default"}}catch(d){let a=d instanceof Error&&(d.message.includes("end of topic")||d.message.includes("no more events")||d.message.includes("offset out of range")||d.message.includes("has no messages")),b=d instanceof Error&&d.message.includes("beginning of topic"),c=d instanceof Error&&d.message.includes("no events found");if(a)return{success:!1,error:"End of topic reached. No more events available.",hasMoreEvents:!1,isAtLatest:!0,isAtEarliest:!1,isEmptyTopic:!1};if(b)return{success:!1,error:"Beginning of topic reached. No previous events available.",hasMoreEvents:!0,isAtLatest:!1,isAtEarliest:!0,isEmptyTopic:!1};if(c)return{success:!1,error:"No events found in this topic.",hasMoreEvents:!1,isAtLatest:!0,isAtEarliest:!0,isEmptyTopic:!0,event:null};return{success:!1,error:d instanceof Error?d.message:"Failed to fetch event",hasMoreEvents:!1,isAtLatest:!1,isAtEarliest:!1,isEmptyTopic:!1,event:null}}finally{try{await j.disconnect()}catch(a){console.error("[KafkaService] Error disconnecting client:",a)}}}}},34753:()=>{}};